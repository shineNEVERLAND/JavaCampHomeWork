1.GC 的时间和存活的对象数量有关，和堆内存的大小关系没有那么大。

2.串行 GC 利用单线程执行，GC 暂停的时间明显会比较长。
  在小堆内存空间的情况下，YoungGC 和 并行GC 的 YoungGC 差不多。
  FullGC 使用的时间明显较长，大概是并行GC 的一倍。
  老年代存活对象占用的空间大，整理移动的时间就长。

3.CMS GC 的老年代清理明显的暂停时间降低。在 GC 日志中有发现 concurrent mode failure 的情况。查询资料后明白，CMS 在 cleanup 是并发执行的，这时的对象引用关系发生改变，也可能有新的对象需要分配空间。如果没有预留足够的空间内存分配就会导致并发失败。可能重新 CMS ，或者 GC 退化成 Serial。

G1 GC 出现了 Humongous Allocation 因为大对象分配失败，触发了 initial-mark。也是重新标记，或者 GC 退化的问题。

 

堆内存越大，内存中可容纳的对象越多，GC 的次数随之减少，单次 GC 的暂停时间可能更长（取决于存活对象的数量）。

 

总的来说，注意不同 GC 策略采用的算法，以及设计的目的。比如 CMS 在于并发执行，提高系统响应。Parallel 更倾向于提高吞吐量；G1 GC 倾向于可配置可预估的暂停时间。

 

CMS - 老年代 没有整理，使用 free-list 管理回收内存；真正的 STW 时间小，但是步骤多，还有浮动垃圾，GC 退化问题。G1 GC 也存在 GC 退化问题。

 

配置堆内存的时候，注意 JVM 自身需要的内存和系统需要的内存，预留一定的空间。

-Xms -Xmx 直接一步到位，扩容的时候有性能的抖动。

年轻代和老年代的比例默认 1:2，新生代:from:to = 8：1：1，根据情况来调整。

根据对象晋升回收速率的计算，进行空间，晋升年龄的配置。